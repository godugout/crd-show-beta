import { readPsd, Layer, LayerTextData } from 'ag-psd';
import { supabase } from '@/integrations/supabase/client';

export interface PSDLayer {
  id: string;
  name: string;
  type: 'text' | 'image' | 'group' | 'shape';
  bounds: {
    x: number;
    y: number;
    width: number;
    height: number;
  };
  content?: {
    text?: string;
    fontSize?: number;
    fontFamily?: string;
    color?: string;
    imageData?: string;
  };
  styleProperties?: {
    opacity?: number;
    blendMode?: string;
    effects?: any[];
  };
  visible: boolean;
  children?: PSDLayer[];
}

export interface GeneratedFrame {
  id: string;
  name: string;
  frameConfig: any;
  layerMapping: Record<string, string>;
  autoGenerated: boolean;
}

export interface PSDProcessingResult {
  layers: PSDLayer[];
  generatedFrames: GeneratedFrame[];
  metadata: {
    width: number;
    height: number;
    colorMode: string;
    bitsPerChannel: number;
  };
}

// Simple processing function for PSDUploadModal
export const processPSDFile = async (file: File): Promise<PSDLayer[]> => {
  try {
    const arrayBuffer = await file.arrayBuffer();
    const psd = readPsd(arrayBuffer, {
      skipLayerImageData: false,
      skipCompositeImageData: true,
      useImageData: true
    });

    if (!psd || !psd.children) {
      return [];
    }

    return extractLayers(psd.children);
  } catch (error) {
    console.error('Error processing PSD file:', error);
    throw new Error(`Failed to process PSD: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
};

const extractLayers = (layers: Layer[]): PSDLayer[] => {
  return layers.map((layer, index) => convertLayer(layer, index));
};

const convertLayer = (layer: Layer, index: number): PSDLayer => {
  const bounds = {
    x: layer.left || 0,
    y: layer.top || 0,
    width: (layer.right || 0) - (layer.left || 0),
    height: (layer.bottom || 0) - (layer.top || 0)
  };

  let type: PSDLayer['type'] = 'image';
  let content: any = {};

  // Determine layer type and extract content
  if (layer.text) {
    type = 'text';
    content = extractTextContent(layer.text);
  } else if (layer.children && layer.children.length > 0) {
    type = 'group';
  } else if (layer.canvas) {
    type = 'image';
    content.imageData = canvasToDataURL(layer.canvas);
  } else {
    type = 'shape';
  }

  const psdLayer: PSDLayer = {
    id: `layer_${index}_${Date.now()}`,
    name: layer.name || `Layer ${index + 1}`,
    type,
    bounds,
    content,
    styleProperties: {
      opacity: layer.opacity !== undefined ? layer.opacity / 255 : 1,
      blendMode: layer.blendMode || 'normal'
    },
    visible: (layer as any).visible !== false
  };

  // Process child layers for groups
  if (layer.children && layer.children.length > 0) {
    psdLayer.children = extractLayers(layer.children);
  }

  return psdLayer;
};

const extractTextContent = (textData: LayerTextData): any => {
  return {
    text: textData.text || '',
    fontSize: textData.style?.fontSize || 12,
    fontFamily: (textData.style as any)?.fontName || 'Arial',
    color: rgbToHex((textData.style as any)?.fillColor) || '#000000'
  };
};

const canvasToDataURL = (canvas: HTMLCanvasElement): string => {
  return canvas.toDataURL('image/png');
};

const rgbToHex = (color?: any): string => {
  if (!color) return '#000000';
  
  // Handle different color formats from ag-psd
  const r = Math.round((color.r || color[0] || 0) * 255);
  const g = Math.round((color.g || color[1] || 0) * 255);
  const b = Math.round((color.b || color[2] || 0) * 255);
  
  return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
};

export class CRDPSDProcessor {
  async processPSD(file: File, onProgress?: (progress: number) => void): Promise<PSDProcessingResult> {
    try {
      onProgress?.(10);

      // Read PSD file
      const arrayBuffer = await file.arrayBuffer();
      onProgress?.(25);

      const psd = readPsd(arrayBuffer, {
        skipLayerImageData: false,
        skipCompositeImageData: true,
        useImageData: true
      });

      onProgress?.(50);

      if (!psd) {
        throw new Error('Failed to parse PSD file');
      }

      // Extract layers
      const layers = this.extractLayers(psd.children || []);
      onProgress?.(70);

      // Generate frames based on layer analysis
      const generatedFrames = this.generateFramesFromLayers(layers, {
        width: psd.width || 0,
        height: psd.height || 0
      });
      onProgress?.(90);

      // Save processing job to database
      await this.saveProcessingJob(file.name, {
        layers,
        generatedFrames,
        metadata: {
          width: psd.width || 0,
          height: psd.height || 0,
          colorMode: psd.colorMode?.toString() || 'RGB',
          bitsPerChannel: psd.bitsPerChannel || 8
        }
      });

      onProgress?.(100);

      return {
        layers,
        generatedFrames,
        metadata: {
          width: psd.width || 0,
          height: psd.height || 0,
          colorMode: psd.colorMode?.toString() || 'RGB',
          bitsPerChannel: psd.bitsPerChannel || 8
        }
      };
    } catch (error) {
      console.error('PSD processing error:', error);
      throw new Error(`Failed to process PSD: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private extractLayers(layers: Layer[]): PSDLayer[] {
    return layers.map((layer, index) => this.convertLayer(layer, index));
  }

  private convertLayer(layer: Layer, index: number): PSDLayer {
    const bounds = {
      x: layer.left || 0,
      y: layer.top || 0,
      width: (layer.right || 0) - (layer.left || 0),
      height: (layer.bottom || 0) - (layer.top || 0)
    };

    let type: PSDLayer['type'] = 'image';
    let content: any = {};

    // Determine layer type and extract content
    if (layer.text) {
      type = 'text';
      content = this.extractTextContent(layer.text);
    } else if (layer.children && layer.children.length > 0) {
      type = 'group';
    } else if (layer.canvas) {
      type = 'image';
      content.imageData = this.canvasToDataURL(layer.canvas);
    } else {
      type = 'shape';
    }

    const psdLayer: PSDLayer = {
      id: `layer_${index}_${Date.now()}`,
      name: layer.name || `Layer ${index + 1}`,
      type,
      bounds,
      content,
      styleProperties: {
        opacity: layer.opacity !== undefined ? layer.opacity / 255 : 1,
        blendMode: layer.blendMode || 'normal'
      },
      visible: (layer as any).visible !== false
    };

    // Process child layers for groups
    if (layer.children && layer.children.length > 0) {
      psdLayer.children = this.extractLayers(layer.children);
    }

    return psdLayer;
  }

  private extractTextContent(textData: LayerTextData): any {
    return {
      text: textData.text || '',
      fontSize: textData.style?.fontSize || 12,
      fontFamily: (textData.style as any)?.fontName || 'Arial',
      color: this.rgbToHex((textData.style as any)?.fillColor) || '#000000'
    };
  }

  private canvasToDataURL(canvas: HTMLCanvasElement): string {
    return canvas.toDataURL('image/png');
  }

  private rgbToHex(color?: any): string {
    if (!color) return '#000000';
    
    // Handle different color formats from ag-psd
    const r = Math.round((color.r || color[0] || 0) * 255);
    const g = Math.round((color.g || color[1] || 0) * 255);
    const b = Math.round((color.b || color[2] || 0) * 255);
    
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
  }

  private generateFramesFromLayers(layers: PSDLayer[], documentSize: { width: number; height: number }): GeneratedFrame[] {
    const frames: GeneratedFrame[] = [];

    // Strategy 1: Full document frame
    frames.push({
      id: `frame_full_${Date.now()}`,
      name: 'Full Document',
      frameConfig: {
        dimensions: { width: documentSize.width, height: documentSize.height },
        regions: [
          {
            id: 'main',
            type: 'content',
            bounds: { x: 0, y: 0, width: documentSize.width, height: documentSize.height },
            constraints: { maintainAspectRatio: true }
          }
        ],
        elements: []
      },
      layerMapping: this.createLayerMapping(layers, 'main'),
      autoGenerated: true
    });

    // Strategy 2: Text-based regions
    const textLayers = this.findTextLayers(layers);
    if (textLayers.length > 0) {
      frames.push({
        id: `frame_text_regions_${Date.now()}`,
        name: 'Text-Based Layout',
        frameConfig: {
          dimensions: { width: documentSize.width, height: documentSize.height },
          regions: this.createTextRegions(textLayers, documentSize),
          elements: this.createTextElements(textLayers)
        },
        layerMapping: this.createTextLayerMapping(textLayers),
        autoGenerated: true
      });
    }

    // Strategy 3: Grid-based layout for multiple elements
    if (layers.length > 3) {
      frames.push({
        id: `frame_grid_${Date.now()}`,
        name: 'Grid Layout',
        frameConfig: {
          dimensions: { width: documentSize.width, height: documentSize.height },
          regions: this.createGridRegions(layers, documentSize),
          elements: []
        },
        layerMapping: this.createGridLayerMapping(layers),
        autoGenerated: true
      });
    }

    return frames;
  }

  private findTextLayers(layers: PSDLayer[]): PSDLayer[] {
    const textLayers: PSDLayer[] = [];
    
    const findText = (layerList: PSDLayer[]) => {
      layerList.forEach(layer => {
        if (layer.type === 'text') {
          textLayers.push(layer);
        }
        if (layer.children) {
          findText(layer.children);
        }
      });
    };
    
    findText(layers);
    return textLayers;
  }

  private createTextRegions(textLayers: PSDLayer[], docSize: { width: number; height: number }) {
    return textLayers.map((layer, index) => ({
      id: `text_region_${index}`,
      type: 'text',
      bounds: {
        x: layer.bounds.x / docSize.width,
        y: layer.bounds.y / docSize.height,
        width: layer.bounds.width / docSize.width,
        height: layer.bounds.height / docSize.height
      },
      constraints: {
        maintainAspectRatio: false,
        allowResize: true
      }
    }));
  }

  private createTextElements(textLayers: PSDLayer[]) {
    return textLayers.map((layer, index) => ({
      id: `text_element_${index}`,
      type: 'text',
      name: layer.name,
      properties: {
        content: layer.content?.text || '',
        font: {
          family: layer.content?.fontFamily || 'Arial',
          size: layer.content?.fontSize || 12,
          color: layer.content?.color || '#000000'
        }
      }
    }));
  }

  private createGridRegions(layers: PSDLayer[], docSize: { width: number; height: number }) {
    const gridSize = Math.ceil(Math.sqrt(layers.length));
    const cellWidth = 1 / gridSize;
    const cellHeight = 1 / gridSize;
    
    return layers.slice(0, gridSize * gridSize).map((layer, index) => {
      const row = Math.floor(index / gridSize);
      const col = index % gridSize;
      
      return {
        id: `grid_region_${index}`,
        type: 'content',
        bounds: {
          x: col * cellWidth,
          y: row * cellHeight,
          width: cellWidth,
          height: cellHeight
        },
        constraints: {
          maintainAspectRatio: true,
          allowResize: false
        }
      };
    });
  }

  private createLayerMapping(layers: PSDLayer[], regionId: string): Record<string, string> {
    const mapping: Record<string, string> = {};
    layers.forEach(layer => {
      mapping[layer.id] = regionId;
    });
    return mapping;
  }

  private createTextLayerMapping(textLayers: PSDLayer[]): Record<string, string> {
    const mapping: Record<string, string> = {};
    textLayers.forEach((layer, index) => {
      mapping[layer.id] = `text_region_${index}`;
    });
    return mapping;
  }

  private createGridLayerMapping(layers: PSDLayer[]): Record<string, string> {
    const mapping: Record<string, string> = {};
    layers.forEach((layer, index) => {
      mapping[layer.id] = `grid_region_${index}`;
    });
    return mapping;
  }

  private async saveProcessingJob(fileName: string, result: PSDProcessingResult): Promise<void> {
    try {
      const { data: job, error: jobError } = await supabase
        .from('crdmkr_processing_jobs')
        .insert({
          file_name: fileName,
          file_url: '', // We'll handle file upload separately if needed
          status: 'completed',
          progress: 100,
          result: result as any
        })
        .select()
        .single();

      if (jobError) {
        console.error('Failed to save processing job:', jobError);
        return;
      }

      // Save layers to database
      const layersToInsert = this.flattenLayersForDB(result.layers, job.id);
      if (layersToInsert.length > 0) {
        const { error: layersError } = await supabase
          .from('psd_layers')
          .insert(layersToInsert);

        if (layersError) {
          console.error('Failed to save layers:', layersError);
        }
      }

      // Save generated frames
      const framesToInsert = result.generatedFrames.map(frame => ({
        job_id: job.id,
        frame_name: frame.name,
        frame_config: frame.frameConfig,
        layer_mapping: frame.layerMapping,
        auto_generated: frame.autoGenerated
      }));

      if (framesToInsert.length > 0) {
        const { error: framesError } = await supabase
          .from('psd_generated_frames')
          .insert(framesToInsert);

        if (framesError) {
          console.error('Failed to save frames:', framesError);
        }
      }
    } catch (error) {
      console.error('Error saving processing job:', error);
    }
  }

  private flattenLayersForDB(layers: PSDLayer[], jobId: string, parentId?: string): any[] {
    const dbLayers: any[] = [];
    
    layers.forEach((layer, order) => {
      const dbLayer = {
        job_id: jobId,
        layer_name: layer.name,
        layer_type: layer.type,
        bounds: layer.bounds,
        content: layer.content,
        style_properties: layer.styleProperties,
        parent_layer_id: parentId || null,
        layer_order: order,
        is_visible: layer.visible
      };
      
      dbLayers.push(dbLayer);
      
      // Recursively process children
      if (layer.children) {
        dbLayers.push(...this.flattenLayersForDB(layer.children, jobId, layer.id));
      }
    });
    
    return dbLayers;
  }
}
